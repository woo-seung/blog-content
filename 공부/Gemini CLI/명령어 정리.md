---
title: 2. 명령어 정리
draft: true
---
# gemini 시작할 때 사용하는 옵션들

## 1. 기본 옵션 훑어보기: --help로 시작하기

Gemini CLI는 다양한 명령줄 옵션을 제공합니다. 이를 확인하려면 터미널에서 간단히 다음 명령어를 실행하면 됩니다.

```
gemini --help
```

이 명령어를 입력하면 다음과 같은 옵션들을 확인할 수 있습니다:

- -m, --model: 사용할 Gemini 모델을 지정합니다. (기본값: gemini-2.5-pro)
- -p, --prompt: 단일 프롬프트로 실행합니다.
- -d, --debug: 디버그 로그를 출력합니다.
- -y, --yolo: 모든 액션을 사용자 확인 없이 자동으로 실행합니다.
- --sandbox: 격리된 샌드박스 환경에서 실행합니다.
- --show_memory_usage: CLI 실행 중 메모리 사용량을 표시합니다.
- --telemetry: CLI 사용 통계를 Google에 전송합니다.

이 옵션들을 잘 이해해두면 터미널 환경에서 Gemini CLI의 기능을 세밀하게 제어할 수 있습니다.

---

## 2. -m (--model) 옵션: 원하는 모델로 바로 실행

Gemini CLI는 기본적으로 gemini-2.5-pro 모델을 사용하지만, 상황에 따라 더 빠른 응답이 필요한 경우 경량화된 gemini-1.5-flash 모델을 사용할 수 있습니다.

```
gemini -m "gemini-1.5-flash"
```

이렇게 모델을 명시적으로 지정하면 작업의 성격에 따라 더 적절한 모델을 활용할 수 있습니다. 단, 무료 계정을 사용하는 경우 모델 사용량 제한으로 인해 자동으로 flash 모델로 대체될 수 있으니, 유료 구독을 고려해보는 것도 좋습니다.

---

## 3. -p (--prompt) 옵션: 단일 입력으로 빠르게 응답 받기

단순한 질문 하나를 하고 결과만 보고 싶은 경우, -p 옵션을 활용하면 대화형 모드를 건너뛰고 바로 결과를 받을 수 있습니다.

예를 들어, 다음과 같이 입력합니다:

```
gemini -p "myhost.com에 GET 요청을 보내는 curl 명령어 알려줘"
```

이 명령어는 대화형 모드 없이 단일 프롬프트의 결과만 출력합니다. 반복적인 테스트나 자동화된 스크립트에 유용하게 활용할 수 있습니다. 다만 이 모드에서는 맥락을 이어가는 대화는 불가능합니다.

---

## 4. -d (--debug) 옵션: 내부 동작을 추적하고 이해하기

개발 과정에서 Gemini CLI가 어떤 식으로 동작하는지 알고 싶다면 디버깅 옵션을 사용하는 것이 효과적입니다.

```
gemini -d -p "리눅스에서 모든 하위 디렉토리의 파일을 이동시키는 명령어는?"
```

이 옵션을 활성화하면 다음과 같은 정보를 확인할 수 있습니다:

- 어떤 폴더에서 실행됐는지
- GEMINI.md 파일의 존재 여부
- 어떤 내용을 프롬프트로 구성했는지
- 모델 호출에 포함된 명세

디버깅 옵션은 특히 CLI가 왜 특정 결과를 반환했는지 추론하고 싶을 때 큰 도움이 됩니다.

---

## 5. -y (--yolo) 옵션: 매번 확인 안 해도 되는 자동화 모드

일일이 사용자 확인을 받지 않고 모든 작업을 자동 승인하고 싶을 땐 --yolo 모드를 사용할 수 있습니다.

```
gemini -y -p "README.md 파일을 생성해줘"
```

이 옵션은 실험적인 기능이나 반복 작업 시 매우 유용합니다. 그러나 삭제, 덮어쓰기 등 민감한 작업에서도 자동으로 실행되므로, 실제 운영 환경에서는 주의해서 사용해야 합니다.

---

## 6. 그 외 유용한 부가 옵션들

- --sandbox: 로컬 파일이나 시스템 환경과 분리된 안전한 환경에서 명령어를 실행합니다. 실험적인 코드나 위험 가능성이 있는 작업에 유용합니다.
- --show_memory_usage: 모델 호출 시 발생하는 메모리 사용량을 CLI 상태바에서 시각적으로 확인할 수 있습니다.
- --telemetry: 사용 통계를 Google에 전송해 더 나은 제품 개선에 기여할 수 있습니다. 원하지 않을 경우 이 옵션을 비활성화하면 됩니다.

---

# 작업 중 명렁어

/ 치면 선택지 나옴

   * /bug: 버그 및 문제 제출   
   * /chat: 대화 기록 저장 (save), 재개 (resume), 목록 확인 (list)   
   * /clear: 터미널 화면 지우기 (단축키: Ctrl+L)   
   * /compress: 전체 대화 내용을 간략하게 요약   
   * /editor: 사용할 편집기 선택   
   * /help: 도움말 정보 표시   
   * /mcp: 설정된 모델 컨텍스트 프로토콜(MCP) 서버 및 도구 목록 확인   
   * /memory: AI의 학습 메모리(GEMINI.md) 관리 (추가 add, 보기 show, 새로고침 refresh)   
   * /restore: 파일을 도구 실행 이전 상태로 복원   
   * /stats: 현재 세션의 통계(토큰 사용량 등) 표시   
   * /theme: CLI의 시각적 테마 변경   
   * /auth: 인증 방법 변경   
   * /about: 버전 정보 표시   
   * /tools: 사용 가능한 도구 목록 표시   
   * /quit 또는 /exit: CLI 종료

At (@) 명령어: 프롬프트에 파일/디렉토리 내용을 포함합니다.  
   * @<파일 또는 디렉토리 경로>: 지정된 파일이나 디렉토리의 내용을 프롬프트에 삽입하여   
     질문할 때 사용합니다. (예: @src/main.js 이 코드에 대해 설명해줘)   
   * 기본적으로 .gitignore에 명시된 파일(예: node_modules)은 제외됩니다.   
   * @ 기호만 단독으로 사용하면, 명령어 대신 @ 문자 자체를 프롬프트에 전달합니다.   
  
  
느낌표 (!) 명령어: 셸(Shell) 명령을 실행합니다.  
   * !<shell_command>: 시스템 셸 명령어를 직접 실행합니다. (예: !ls -la, !git status)   
   * !만 단독으로 입력하면 '셸 모드'로 전환/해제됩니다. 이 모드에서는 모든 입력이 셸   
     명령으로 처리됩니다.



위 내용은 아래 글들을 기반으로 정리한 내용임.
- https://digitalbourgeois.tistory.com/1557
- https://dpcks5959.tistory.com/144